## Быстрая памятка для AI-агента — xmr_scanner

Ниже — концентрированная информация, которая поможет быстро вникнуть и вносить изменения в этот репозиторий.

1) Большая картина
- Проект — легковесный сканер цепочки Monero (XMR). Основные компоненты:
  - bScanner / ScannerXMR (файл `index.go` + `main.go`) — логика синхронизации цепочки и управления соединением.
  - Пакет `levin/` — реализация протокола LEVIN (заголовки, команды, сериализация). Это сердце сетевого взаимодействия.
  - `database.go` — мок-адаптер БД (`DatabaseMock`) и список нод (`Nodelist`). Продемонстрированы конвенции формата ноды `ip:port`.
  - `pool.go` — очередь/пул блоков (`Pool`, `Block`) с простыми мьютексами для конкурентного доступа.
  - `main.go`, `main2.go` — точки запуска/эксперименты: `main.go` показывает парсинг дампа и работу с `levin.PortableStorage`, `main2.go` — моковый пример запуска сканера.

2) Ключевые интерфейсы и точки расширения
- `Notifier` (см. `index.go`, константы уровней в `main.go`) — используйте для логирования/уведомлений; проект предпочитает формат с уровнями (LevelInfo/Success/Warning/Error).
- `DBWrapper` (в `index.go`) — контракт для доступа к нодам и обработке блоков: GetNodeAddrs, GetChainHeight, ProcessBlock. Подменяется `DatabaseMock`.
- `Scanner`/`ScannerXMR` (в `main.go`) — основная реализация; расширяйте сюда поддержку других монет через `New` в `index.go`.

3) Важные реалии/конвенции кода
- Ноды хранятся как список строк `"ip:port"` (см. `database.go`). Никогда не меняйте формат без коррекции резолвера.
- Начальная синхронизация строится из набора высот в `GenerateSequence()` (фиксированный алгоритм: 11 последних, экспоненциальная последовательность и 0). Меняйте осторожно — на него опирается логика запроса цепочки.
- Сетевая логика использует `levin.Client` (в `levin/*`) — команды/обработчики перечислены в `levin/levin.go`. Новые команды добавляйте туда и в switch в `handleMessage` (см. `main.go`).
- Работа с payload: проект использует `levin.PortableStorage` и методы `Entries()`, `BoostBlock`, `BoostBlockIds`, `BoostString` — придерживайтесь этой сериализации при формировании запросов.

4) Паттерны конкурентности
- Основной цикл сканера запускает несколько горутин: `GetBlockDataLoop`, `KeepConnectionLoop`, `ReadStreamLoop` (см. `main.go` — `MainLoop`).
- `Pool` защищён mutex`ом; итерация через `Range` держит блокировку на всё тело итерации — избегайте долгих/блокирующих операций внутри `Range`.

5) Внешние интеграции и опасные места
- HTTP scraping: `GetXMRChain` делает GET на `https://xmrchain.net/search?value=%d` и парсит HTML регулярками — ненадёжен и хрупок; улучшать осторожно.
- Сетевые подключения — `levin.Client.Handshake()` и `SendRequest/SendResponse` — при изменении формата заголовков смотрите `levin/levin.go` (Header.Bytes / NewHeaderFromBytesBytes).

6) Быстрые команды для разработчика
- Сборка: `go build ./...`
- Запуск (локально): `go run main.go` или `go run main2.go` для тестовых сценариев.
- Проверки: `go vet ./...` и `go fmt` перед коммитом.

7) Примеры кода (копируйте/следуйте стилю)
- Формирование запроса цепочки: в `SendRequestChain()` (файл `main.go`) используется `levin.PortableStorage{ Entries: []levin.Entry{{Name: "block_ids", Serializable: levin.BoostBlockIds(p.GetBlockHashes())}}}` — используйте аналогичный подход.
- Обработка входящих сообщений: `handleMessage(header, raw)` содержит switch по `header.Command`; добавляйте новые ветки там.

8) Что важно для PR/исправлений
- Не нарушайте контракт `DBWrapper` и `Notifier` — это точки подмены для тестов/моков.
- Тесты пока отсутствуют; при добавлении новых публичных функций добавляйте маленькие unit tests и избегайте обращения к реальной сети — мокируйте `levin.Client`.

Если что-то непонятно или нужен более детальный кусок (например, конкретные сигнатуры в `levin` или пример мокирования `levin.Client`), скажите — добавлю секцию или примеры кода.
